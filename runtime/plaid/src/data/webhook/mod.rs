use core::panic;
use std::{collections::HashMap, convert::Infallible, net::SocketAddr, pin::Pin, sync::Arc, time::{SystemTime, UNIX_EPOCH}};

use crossbeam_channel::{Sender, TrySendError};
use plaid_stl::messages::{LogSource, LogbacksAllowed};
use serde::Deserialize;
use serde::de;
use tokio::sync::RwLock;

use crate::{executor::{LogMessage, Message, ResponseMessage}, loader::PlaidModule, ModulesByName};

use warp::{filters::body, http::HeaderMap, hyper::body::Bytes, path, Filter};


/// How should responses to GET requests be cached.
#[derive(Default, Deserialize, Clone)]
#[serde(tag = "type")]
pub enum CachingMode {
    /// Do not cache.
    #[default]
    None,
    /// Run then cache the result for the given period of time. The
    /// cache will be invalidated after the given period of time has
    /// passed.
    Timed { validity: u64 },
    /// This will use a stored cache from whatever the response method is
    /// before running the response method again. This means that GET calls
    /// should always be fast as the cache is only updated by other means.
    ///
    /// The exception is if call_on_none is set to true, in which case if
    /// nothing is stored, this will act as if Cache::None was set for the first
    /// call.
    UsePersistentResponse { call_on_none: bool },
}

/// How should a webhook respond to a GET request
#[derive(Clone)]
pub enum ResponseMode {
    /// Respond the way Facebook expects, needs a secret token
    Facebook(String),
    /// Respond by running a plaid wasm module to generate the response
    Rule(String),
    /// Static response
    Static(String),
}

/// Some services have verification routines that need to happen before
/// data will be sent to them. To make the system more general you can
/// specify on each webhook what kind of response you'd like to use
/// to pass this verification.
///
/// This configuration controls how a webserver will respond to GET
/// requests.
#[derive(Deserialize, Clone)]
pub struct GetMode {
    /// Set how the data sent in GET responses should be cached. This is really
    /// only useful when the response_mode is set to ResponseMode::Rule but in future
    /// this may be applicable to other, newer, modes.
    #[serde(default)]
    pub caching_mode: CachingMode,
    #[serde(deserialize_with = "response_mode_deserializer")]
    pub response_mode: ResponseMode,
}

/// Configuration for a particular webhook within a WebhookServer to accept
/// logs and send them to a logging channel
#[derive(Deserialize, Clone)]
pub struct WebhookConfig {
    /// The logging channel that POST bodies will be sent to
    pub log_type: String,
    /// What headers do you want forwarded to the logging channel as well under
    /// accessory data. If these headers conflict with set secrets, the secrets
    /// will be used and the header ignored.
    pub headers: Vec<String>,
    /// See GetMode
    pub get_mode: Option<GetMode>,
    /// An optional label for the webhook. If this is populated, it will be
    /// passed as the source to to the modules instead of the webhook address.
    /// You may want to do this to reduce the secrets modules have access to.
    pub label: Option<String>,
    /// The maximum number of logbacks that each rule will be allowed to trigger
    /// per message received. If this is set to Limited(0), no rule will be able to use the log
    /// back functionality from messages generated by this webhook. If this is set to Limited(1),
    /// then EACH RULE will be able to trigger one logback. If this is set to Unlimited, then
    /// each rule will be able to trigger as many logbacks as they want (and those triggered rules
    /// will be able to as well). If this is not set, it will default to Limited(0).
    #[serde(default)]
    pub logbacks_allowed: LogbacksAllowed,
}

#[derive(Deserialize)]
pub struct WebhookServerConfiguration {
    /// The address and port to listen on for webhooks
    pub listen_address: String,
    /// The mapping of webhooks to configuration of the webhook
    #[serde(default)]
    pub webhooks: HashMap<String, WebhookConfig>,
}

pub type WebhookServerConfigurations = HashMap<String, WebhookServerConfiguration>;


fn response_mode_deserializer<'de, D>(deserializer: D) -> Result<ResponseMode, D::Error>
where
    D: de::Deserializer<'de>,
{
    let mode = String::deserialize(deserializer)?;

    let mut pieces: Vec<&str> = mode.split(":").collect();

    let data = pieces.pop().ok_or(serde::de::Error::custom(
        "Must provide context for the response_mode. For Facebook/Meta this is the secret, for Rule this is the module name",
    ))?;

    let mode = pieces
        .pop()
        .ok_or(serde::de::Error::custom("Must provide a response_mode"))?;

    Ok(match mode {
        "facebook" | "meta" => ResponseMode::Facebook(data.to_owned()),
        "Rule" | "rule" => ResponseMode::Rule(data.to_owned()),
        "Static" | "static" => ResponseMode::Static(data.to_owned()),
        x => {
            return Err(serde::de::Error::custom(format!(
                "{x} is an unknown response_mode. Must be 'facebook', 'rule', or 'static'"
            )))
        }
    })
}

pub fn configure_webhooks(config: WebhookServerConfigurations, log_sender: Sender<Message>) -> Vec<Box<Pin<Box<dyn futures_util::Future<Output = ()> + Send >>>> {
    let webhook_server_post_log_sender = log_sender.clone();
    let webhook_servers: Vec<Box<Pin<Box<_>>>> = config
        .into_iter()
        .map(|(server_name, config)| {
            let webhook_server_post_log_sender = webhook_server_post_log_sender.clone();
            let server_address: SocketAddr = config
                .listen_address
                .parse()
                .expect("A server had an invalid address");

            let webhooks = config.webhooks.clone();
            let post_route = warp::post()
                .and(warp::body::content_length_limit(1024 * 256))
                .and(path!("webhook" / String))
                .and(warp::body::bytes())
                .and(warp::header::headers_cloned())
                .map(move |webhook: String, data: Bytes, headers: HeaderMap| {
                    // If this is a webhook that is configured
                    if let Some(webhook_configuration) = webhooks.get(&webhook) {

                        // If the webhook has a label, use that as the source, otherwise use the webhook address
                        let source = match webhook_configuration.label {
                            Some(ref label) => LogSource::WebhookPost(label.to_string()),
                            None => LogSource::WebhookPost(webhook.to_string()),
                        };

                        let logbacks_allowed = webhook_configuration.logbacks_allowed.clone();

                        // Create the message we're going to send into the execution system.
                        let mut log_message = LogMessage::new(webhook_configuration.log_type.to_owned(), data[..].to_vec(), source, logbacks_allowed);

                        for requested_header in webhook_configuration.headers.iter() {
                            // TODO: Investigate if this should be get_all?
                            // Without this we don't support receiving multiple headers with the same name
                            // I don't know if this is an issue or not, practicially, or if there are security implications.
                            if let Some(value) = headers.get(requested_header) {
                                log_message.accessory_data.insert(requested_header.to_string(), value.as_bytes().to_vec());
                            }
                        }

                        // Webhook exists, buffer log
                        if let Err(e) = webhook_server_post_log_sender.try_send(log_message.into()) {
                            match e {
                                TrySendError::Full(_) => error!("Queue Full! [{}] log dropped!", webhook_configuration.log_type),
                                // TODO: Have this actually cause Plaid to exit
                                TrySendError::Disconnected(_) => panic!("The execution system is no longer accepting messages. Nothing can continue."),
                            }
                        }
                    }
                    // Always Empty Response
                    Box::new(warp::reply())
                });

            // This is a cache for get requests that are configured to be cached
            // Webhook -> (timestamp, response)
            let get_cache: Arc<RwLock<HashMap<String, (u64, String)>>> = Arc::new(RwLock::new(HashMap::new()));
            let webhook_server_get_log_sender = log_sender.clone();
            let webhook_config = Arc::new(config);
            let get_route = warp::get()
                .and(path!("webhook" / String))
                .and(warp::query::<HashMap<String, String>>())
                .and(with(webhook_config.clone()))
                .and(with(get_cache.clone()))
                .and(with(webhook_server_get_log_sender.clone()))
                .and_then(|webhook: String, query: HashMap<String, String>, webhook_config: Arc<WebhookServerConfiguration>, get_cache: Arc<RwLock<HashMap<String, (u64, String)>>>, log_sender: crossbeam_channel::Sender<Message>| async move {
                    if let Some(webhook_configuration) = webhook_config.webhooks.get(&webhook) {
                        match &webhook_configuration.get_mode {
                            // Note that CacheMode is elided here as there is no caching for static data
                            Some(GetMode{ response_mode: ResponseMode::Static(data), ..}) => {
                                Ok(warp::reply::html(data.clone()))
                            }
                            // Note that CacheMode is elided here as there is no caching possible for
                            // Facebook verification
                            Some(GetMode{ response_mode: ResponseMode::Facebook(secret), ..}) => {
                                if let Some(fb_secret) = query.get("hub.verify_token") {
                                    if fb_secret == secret {
                                        info!("Received a valid get request to: {webhook}");
                                        Ok::<warp::reply::Html<String>, Infallible>(warp::reply::html(query.get("hub.challenge").unwrap_or(&String::new()).to_owned()))
                                    } else {
                                        error!("Got a request that didn't contain the right FB secret");
                                        Ok(warp::reply::html(String::new()))
                                    }
                                } else {
                                    warn!("Got a call that didn't contain the right FB parameters. Webhook leaked?");
                                    Ok(warp::reply::html(String::new()))
                                }
                            },
                            // For rules, we do need to get the cache mode and dealing with it makes this
                            // kind of reponse significantly more complex.
                            Some(GetMode{ response_mode: ResponseMode::Rule(module_name), caching_mode}) => {
                                // Ensure that the rule configured to generated the GET response actually exists
                                // let rule = if let Some(rule) = modules.get(name) {
                                //     rule
                                // } else {
                                //     warn!("Got a get request to {webhook} but the rule [{name}] configured to handle it does not exist");
                                //     return Ok(warp::reply::html(String::new()));
                                // };

                                info!("Received get request to: {webhook}. Handling with rule [{module_name}] to generate response");
                                // I'm making the assumption here that getting the system time will never fail
                                let current_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();

                                // Determine if we need to update the cache at the end of this request 
                                let update = match caching_mode {
                                    CachingMode::Timed{validity} => {
                                        let cache = get_cache.read().await;
                                        if let Some(cached_response) = cache.get(&webhook) {
                                            if cached_response.0 + validity > current_time {
                                                info!("Returning cached response (valid for {} more seconds) for get request to: {webhook}", cached_response.0 + validity - current_time);
                                                return Ok(warp::reply::html(cached_response.1.clone()));
                                            }
                                        }
                                        true
                                    },
                                    CachingMode::None => false,
                                    CachingMode::UsePersistentResponse { call_on_none } => {
                                        let (response_sender, response_recv) = tokio::sync::oneshot::channel();
                                        let persistent_response_message = Message::FetchPersistentResponse { module_name: module_name.clone(), response_sender };
                                        
                                        // Put the message into the standard message queue
                                        if let Err(e) = log_sender.try_send(persistent_response_message.into()) {
                                            match e {
                                                TrySendError::Full(_) => error!("Queue Full! [{}] log dropped!", webhook_configuration.log_type),
                                                // TODO: Have this actually cause Plaid to exit
                                                TrySendError::Disconnected(_) => panic!("The execution system is no longer accepting messages. Nothing can continue."),
                                            }
                                        };

                                        match response_recv.await {
                                            Ok(Some(ResponseMessage { code: 200, body})) => {
                                                info!("Returning persistent response for get request to: {webhook}");
                                                return Ok(warp::reply::html(body));
                                            },
                                            Ok(Some(ResponseMessage { code, ..})) => {
                                                warn!("Module {module_name} returned status code [{code}] so we're returning an empty response");
                                                return Ok(warp::reply::html(String::new()));
                                            },
                                            Ok(None) => {
                                                // We don't want to call on none so even though there is no persistent response
                                                // we don't run the rule and just return no data
                                                if !call_on_none {
                                                    warn!("There was no response from {module_name} so we're returning an empty response and we're not calling the module to get one because call_on_none is false");
                                                    return Ok(warp::reply::html(String::new()));
                                                }
                                                false
                                            },
                                            Err(e) => {
                                                error!("Got a get request to {webhook} but the rule [{module_name}] configured to handle it threw an error: {e}");
                                                return Ok(warp::reply::html(String::new()));
                                            },
                                        }

                                    }, 
                                };

                                // If the webhook has a label, use that as the source, otherwise use the webhook address
                                let source = match webhook_configuration.label {
                                    Some(ref label) => LogSource::WebhookGet(label.to_string()),
                                    None => LogSource::WebhookGet(webhook.to_string()),
                                };

                                let logbacks_allowed = webhook_configuration.logbacks_allowed.clone();

                                let (response_send, response_recv) = tokio::sync::oneshot::channel();

                                // Construct a message to send to the rule
                                let message = LogMessage {
                                    type_: module_name.to_string(),
                                    data: String::new().into_bytes(),
                                    accessory_data: query.into_iter().map(|(k, v)| (k, v.into_bytes())).collect(),
                                    source,
                                    logbacks_allowed,
                                    response_sender: Some(response_send),
                                    module: Some(module_name.clone()),
                                };

                                // Put the message into the standard message queue
                                if let Err(e) = log_sender.try_send(message.into()) {
                                    match e {
                                        TrySendError::Full(_) => error!("Queue Full! [{}] log dropped!", webhook_configuration.log_type),
                                        // TODO: Have this actually cause Plaid to exit
                                        TrySendError::Disconnected(_) => panic!("The execution system is no longer accepting messages. Nothing can continue."),
                                    }
                                }

                                match response_recv.await {
                                    Ok(Some(response))=> {
                                        if update {
                                            info!("Updating cache for get request to: {webhook}");
                                            let current_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
                                            let mut cache = get_cache.write().await;
                                            cache.insert(webhook.clone(), (current_time, response.body.clone()));
                                        }
                                        Ok(warp::reply::html(response.body))
                                    },
                                    Ok(None) => {
                                        warn!("Got a get request to {webhook} but the rule [{module_name}] configured to handle it did not return a response");
                                        Ok(warp::reply::html(String::new()))
                                    }
                                    // TODO @obelisk: This also happens if the module configured to handle this doesn't exist as the executor
                                    // will fail to find the module and drop the sender. In the future, this might be better if when that happened 
                                    // the executor send an error enum through the OneShot channel.
                                    Err(e) => {
                                        error!("Got a get request to {webhook} but the rule [{module_name}] configured to handle it threw an error: {e}");
                                        Ok(warp::reply::html(String::new()))
                                    }
                                }
                            },
                            None => {
                                // This occurs when a webhook receives a get request but there is no configuration for how
                                // GET requests should be handled. Usually this is the result of a service misconfiguration
                                // where it should be sending POSTs.
                                warn!("Got a get request to {webhook}. Are you sure the sending service is configured correctly?");
                                Ok(warp::reply::html(String::new()))
                            },
                        }
                    } else {
                        Ok(warp::reply::html(String::new()))
                    }
                });

            let routes = post_route.or(get_route);

            info!("Web Server [{server_name}]: {server_address}");
            Box::<Pin<Box<(dyn futures_util::Future<Output = ()> + 'static + Send)>>>::new(Box::pin(
                warp::serve(routes).run(server_address),
            ))
        })
        .collect();

        webhook_servers
    }


fn with<T>(users: T) -> impl Filter<Extract = (T,), Error = Infallible> + Clone
where
    T: Send + Sync + Clone,
{
    warp::any().map(move || users.clone())
}